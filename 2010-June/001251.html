<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Automatic detection of reception modes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/fldigi-alpha/2010-June/index.html" >
   <LINK REL="made" HREF="mailto:fldigi-alpha%40lists.berlios.de?Subject=Re%3A%20Automatic%20detection%20of%20reception%20modes&In-Reply-To=%3Cdb64a64fe39674b35594974b010cddcc.squirrel%40graflex.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001250.html">
   <LINK REL="Next"  HREF="001252.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Automatic detection of reception modes</H1>
    <B>Leigh L. Klotz, Jr. WA5ZNU</B> 
    <A HREF="mailto:fldigi-alpha%40lists.berlios.de?Subject=Re%3A%20Automatic%20detection%20of%20reception%20modes&In-Reply-To=%3Cdb64a64fe39674b35594974b010cddcc.squirrel%40graflex.org%3E"
       TITLE="Automatic detection of reception modes">Leigh at WA5ZNU.org
       </A><BR>
    <I>Wed Jun  2 19:45:43 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001250.html">Automatic detection of reception modes
</A></li>
        <LI>Next message: <A HREF="001252.html">RSID and Squelch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1251">[ date ]</a>
              <a href="thread.html#1251">[ thread ]</a>
              <a href="subject.html#1251">[ subject ]</a>
              <a href="author.html#1251">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dave,
This went only to me.  I think you wanted to send it to the list?

BTW I was involved in the development of the visual ID, in 2004-2005,
during previous discussion about the ID.  I also was the one who got
implementation details from Patrick FC6TE about how RSID worked, since
originally he had it only in MultiPSK and there wasn't enough information,
though of course Stelios and Dave did the implementation.

Here's previous discussion from 2005 on parallel-decoding:

<A HREF="http://www.mail-archive.com/digitalradio@yahoogroups.com/msg02826.html">http://www.mail-archive.com/digitalradio@yahoogroups.com/msg02826.html</A>

Here's my 2004 write-up of the Visual CQ:
<A HREF="http://wa5znu.org/log/2004/09/psk-visual-cq.html">http://wa5znu.org/log/2004/09/psk-visual-cq.html</A>

As for ear signal processing (ESP?) I have a lot of trouble telling the
difference between Domino and Domino-FEC, and also am not too good at
distinguishing QPSK63 from PSK63.  Thor and Domino look a lot alike to me,
too.

Leigh/WA5ZNU.

&gt;<i> GM Gentlemen,
</I>&gt;<i>
</I>&gt;<i> So what do you call the RSID feature built into FLDIGI if not automatic
</I>&gt;<i> mode recognition? The only drawback I see to it is that it requires the
</I>&gt;<i> cooperation of the TXing station.  Otherwise, it does a great job for
</I>&gt;<i> recognizing the various modes automatically.   Or, what about the video
</I>&gt;<i> IDer?  You can send the mode with it.
</I>&gt;<i>
</I>&gt;<i> Actually, the best automatic mode recognition software available is
</I>&gt;<i> between the ears.  With a combination of listening to, and looking at, the
</I>&gt;<i> signal on the waterfall a lot of the digital modes can be identified or a
</I>&gt;<i> lot can be eliminated from the list of modes the signal might be.  Of
</I>&gt;<i> course, the caveat to that is it takes some practice and some people just
</I>&gt;<i> don't want to take the time to practice!!
</I>&gt;<i>
</I>&gt;<i> Anyway, FWIW as usual.
</I>&gt;<i>
</I>&gt;<i> Dave K3GAU
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> &quot;Leigh L. Klotz, Jr. WA5ZNU&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">Leigh at WA5ZNU.org</A>&gt; 6/1/2010 8:28 PM &gt;&gt;&gt;
</I>&gt;<i> It may be that Dave et. al. decide not to incorporate an automatic mode
</I>&gt;<i> recognition feature, and so an external program may be the only route, but
</I>&gt;<i> I'd hope not since I think automatic mode recognition inside fldigi would
</I>&gt;<i> be great.
</I>&gt;<i>
</I>&gt;<i> However, I'd like to suggest separating the incremental development of
</I>&gt;<i> such a feature from its eventual implementation.  Personally I think it's
</I>&gt;<i> more easily developed and prototyped externally because of the ease of
</I>&gt;<i> writing the test programs and algorithms in scripting languages such as
</I>&gt;<i> Perl or Python.
</I>&gt;<i>
</I>&gt;<i> Leigh/WA5ZNU
</I>&gt;<i>
</I>&gt;&gt;<i> Sounds like an excellent candidate for a separate program.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This might be somewhat involved from what I am hearing and if the
</I>&gt;&gt;<i> approach
</I>&gt;&gt;<i> would turn out to be like
</I>&gt;&gt;<i> ALE , if not a separate program then perhaps a separate fork.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I haven't experienced the difficulty in identifying signals especially
</I>&gt;&gt;<i> since
</I>&gt;&gt;<i> the samples of the different modes
</I>&gt;&gt;<i> supported in Fldigi were posted some time ago.  That was very nice
</I>&gt;&gt;<i> indeed.
</I>&gt;&gt;<i> We use it in our training very heavily along with
</I>&gt;&gt;<i> the throughput charts to help folks understand why one might choose a
</I>&gt;&gt;<i> particular mode over another.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Just my thoughts.  It is an intriguing idea though.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 73's
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Mike
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Tue, Jun 1, 2010 at 7:23 PM, <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">remi.chateauneu at gmail.com</A> &lt;
</I>&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">remi.chateauneu at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Thanks for the answer.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Maybe we could have this kind of architecture:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * A scanning module which handles the logic of working on a range
</I>&gt;&gt;&gt;<i> frequency, with given steps depending on the frequency. Tempo for each
</I>&gt;&gt;&gt;<i> frequency, loop or stop after one scan, etc... ( xml-rpc
</I>&gt;&gt;&gt;<i> main.set_frequency
</I>&gt;&gt;&gt;<i> ). It might run as well on a list of predefined frequencies (ALE).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * A list of 'reasonable'  modes to try, based on the frequency and user
</I>&gt;&gt;&gt;<i> choices. Based on usual rules and frequency usage.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * A module which 'decides' to 'try' a frequency because there is a
</I>&gt;&gt;&gt;<i> signal.
</I>&gt;&gt;&gt;<i> It uses the signal/noise ratio, and can be customized given the mode,
</I>&gt;&gt;&gt;<i> but by
</I>&gt;&gt;&gt;<i> default just uses the power. Maybe uses xml-rpc modem.get_quality
</I>&gt;&gt;&gt;<i> function ?
</I>&gt;&gt;&gt;<i> Or modem.search_up and modem.search_down, but at the moment the virtual
</I>&gt;&gt;&gt;<i> function modem::searchUp is implemented only for psk and rtty, and we
</I>&gt;&gt;&gt;<i> would
</I>&gt;&gt;&gt;<i> also have to extend the maximum frequency where this function can go,
</I>&gt;&gt;&gt;<i> because it is limited at the moment to IMAGE_WIDTH-bandwidth.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * A module which 'tries' to decode ( text.get_rx / main.rx ) with the
</I>&gt;&gt;&gt;<i> current mode and, given the result, decide whether it is positive or
</I>&gt;&gt;&gt;<i> not.
</I>&gt;&gt;&gt;<i> Depending on the modem, it can be the entropy, or a reasonable number
</I>&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;<i> English words, etc... abstracted in a boolean value. Uses
</I>&gt;&gt;&gt;<i> modem.set_by_id
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * An optional module sending a specific message when something is
</I>&gt;&gt;&gt;<i> detected
</I>&gt;&gt;&gt;<i> on a frequency ( main.run_macro or main.tx ). It would wait until the
</I>&gt;&gt;&gt;<i> current emission is finished.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * A function which saves the frequency map + time + detected sample, in
</I>&gt;&gt;&gt;<i> a
</I>&gt;&gt;&gt;<i> browsable format (DBLog database or ADIF for example)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Would we create a new program or adds this to an existing prog ? Or
</I>&gt;&gt;&gt;<i> create
</I>&gt;&gt;&gt;<i> a super-macro ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Thanks
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Remi
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Leigh L. Klotz, Jr WA5ZNU wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I wanted to do this a few years ago; one idea I had then was letting
</I>&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;<i> user pick the bandwidth of the signal, and then decoding and measuring
</I>&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;<i> entropy of the received text.  It might be good to use the network
</I>&gt;&gt;&gt;&gt;<i> interface
</I>&gt;&gt;&gt;&gt;<i> to do this, because you then have the freedom to prototype in any
</I>&gt;&gt;&gt;&gt;<i> language.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I've done some tests and just calculating entropy or Phi value
</I>&gt;&gt;&gt;&gt;<i> (approximation of English letter frequency) isn't good enough yet.
</I>&gt;&gt;&gt;&gt;<i> I did this by analyzing fldigi log files, not by comparing decoding
</I>&gt;&gt;&gt;&gt;<i> output
</I>&gt;&gt;&gt;&gt;<i> of different modems, so maybe entropy would be good enough.
</I>&gt;&gt;&gt;&gt;<i> Phi is not useful, though, because of the high frequency of acronyms,
</I>&gt;&gt;&gt;&gt;<i> Q-signals, and numeric reports in short samples of QSOs.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Leigh/WA5ZNU
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On 05/31/2010 02:00 PM, <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">remi.chateauneu at gmail.com</A> wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Thanks for the answer. This is something like that I have in mind: A
</I>&gt;&gt;&gt;&gt;&gt;<i> kind
</I>&gt;&gt;&gt;&gt;&gt;<i> of software-based scanner looping on every frequency of a given
</I>&gt;&gt;&gt;&gt;&gt;<i> frequency
</I>&gt;&gt;&gt;&gt;&gt;<i> range, with a given step.
</I>&gt;&gt;&gt;&gt;&gt;<i> At each step, it measures the signal/noise ratio. If it is powerful
</I>&gt;&gt;&gt;&gt;&gt;<i> enough, it tries a subset of modem types (Subset based on the
</I>&gt;&gt;&gt;&gt;&gt;<i> frequency for
</I>&gt;&gt;&gt;&gt;&gt;<i> example). For each of them, it waits a couple of seconds, and tries
</I>&gt;&gt;&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;&gt;&gt;<i> decode something meaningful. Instead of looping on a frequency rqnge,
</I>&gt;&gt;&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;&gt;&gt;<i> might as well try a list of given frequencies.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> If it can find something 'interesting' (Occurence of given strings
</I>&gt;&gt;&gt;&gt;&gt;<i> such
</I>&gt;&gt;&gt;&gt;&gt;<i> as 'CQ', callsigns, english words etc...) , it writes the data and
</I>&gt;&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;&gt;<i> frequency in a logbook (Or database like DBlog's one).
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> I wondered whether &lt;SRCHUP&gt; and &lt;SRCHDN&gt; may help, but I could not
</I>&gt;&gt;&gt;&gt;&gt;<i> really
</I>&gt;&gt;&gt;&gt;&gt;<i> understand them nor make them work.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Thanks
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> R
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Andy obrien wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> I have a problem guessing which are the transmit modes of some
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> signals
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> we receive.
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> So, do you please think it would be possible to have an automatic
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> system
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> for guessing the mode of a signal ?
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> Something which would try all fldigi modes, wait a couple of
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> seconds
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> decode something,
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> You may be able to do thisalready via the macros.  To save sometime,
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> break it down in to a couple of macros differentiated by distinct
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> classes of signals, leave out the ones you are already knowledgeable
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> about (e.g. RTTY is so distinct you probably do not need that in a
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> macro, same for PSK31.  )  example
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> &lt;MODEM:CTSTIA:250:8&gt;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> &lt;MODEM:CTSTIA:500:16&gt;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> &lt;MODEM:CTSTIA:1000:8&gt;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> &lt;MODEM:CTSTIA:1000:16&gt;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> &lt;MODEM:CTSTIA:500:8&gt;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> and play around with the &lt;TIMER:NN&gt;  commands in between each mode
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> command.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Andy K3UK
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> fldigi-alpha mailing list
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">fldigi-alpha at lists.berlios.de</A>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">https://lists.berlios.de/mailman/listinfo/fldigi-alpha</A>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;&gt;<i> fldigi-alpha mailing list
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">fldigi-alpha at lists.berlios.de</A>
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">https://lists.berlios.de/mailman/listinfo/fldigi-alpha</A>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> fldigi-alpha mailing list
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">fldigi-alpha at lists.berlios.de</A>
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">https://lists.berlios.de/mailman/listinfo/fldigi-alpha</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> fldigi-alpha mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">fldigi-alpha at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">https://lists.berlios.de/mailman/listinfo/fldigi-alpha</A>
</I>&gt;<i>
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001250.html">Automatic detection of reception modes
</A></li>
	<LI>Next message: <A HREF="001252.html">RSID and Squelch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1251">[ date ]</a>
              <a href="thread.html#1251">[ thread ]</a>
              <a href="subject.html#1251">[ subject ]</a>
              <a href="author.html#1251">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/fldigi-alpha">More information about the fldigi-alpha
mailing list</a><br>
</body></html>
